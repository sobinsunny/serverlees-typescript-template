'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const _require = require('lodash'),
      values = _require.values;

module.exports = function noWildIamPolicy(policy, service) {
  let failed = false;
  const Resources = service.compiled['cloudformation-template-update-stack.json'].Resources;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = values(Resources)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      const _step$value = _step.value,
            Type = _step$value.Type,
            Properties = _step$value.Properties;

      if (Type !== 'AWS::IAM::Role') {
        continue;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (Properties.Policies || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          const iamPolicy = _step2.value;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = iamPolicy.PolicyDocument.Statement[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              const _step3$value = _step3.value,
                    Effect = _step3$value.Effect,
                    Action = _step3$value.Action,
                    Resource = _step3$value.Resource;

              if (Effect === 'Deny') {
                continue;
              }

              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = Action[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  const action = _step4.value;

                  if (action === '*') {
                    failed = true;
                    policy.fail("iamRoleStatement granting Action='*'. Wildcard actions in iamRoleStatements are not permitted.");
                  }

                  if (action.split(':')[1] === '*') {
                    failed = true;
                    policy.fail(`iamRoleStatement granting Action='${action}'. Wildcard actions in iamRoleStatements are not permitted.`);
                  }
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }

              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = (Array.isArray(Resource) ? Resource : [Resource])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  const rawResource = _step5.value;
                  let resourceStr = rawResource;

                  if (typeof rawResource === 'object') {
                    if ('Fn::Join' in rawResource) {
                      resourceStr = rawResource['Fn::Join'][1].join(rawResource['Fn::Join'][0]);
                    } else if ('Fn::Sub' in rawResource) {
                      if (typeof rawResource['Fn::Sub'] === 'string') {
                        resourceStr = rawResource['Fn::Sub'].replace(/\$\{[^$]*\}/g, 'variable');
                      } else {
                        resourceStr = rawResource['Fn::Sub'][0].replace(/\$\{[^$]*\}/g, 'variable');
                      }
                    }
                  }

                  if (resourceStr === '*') {
                    failed = true;
                    policy.fail("iamRoleStatement granting Resource='*'. Wildcard resources in iamRoleStatements are not permitted.");
                  } else if (typeof resourceStr === 'string') {
                    const _resourceStr$split = resourceStr.split(':'),
                          _resourceStr$split2 = _slicedToArray(_resourceStr$split, 7),
                          arnService = _resourceStr$split2[2],
                          resourceType = _resourceStr$split2[5],
                          resource = _resourceStr$split2[6];

                    if (arnService === '*' || resourceType === '*' || resource === '*') {
                      failed = true;
                      policy.fail(`iamRoleStatement granting Resource=${JSON.stringify(rawResource)}. Wildcard resources or resourcetypes in iamRoleStatements are not permitted.`);
                    }
                  } else {
                    /*
                     * if resourceStr isn't a string, it's probably an object
                     * containing a `Ref` or CFN function like `Fn::GetAtt` which are difficult to resolve
                     * cases like `Ref` are most likely safe. Explicitly bad cases using `Fn::Join` with
                     * all literals, are handled above.
                     */
                  }
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (!failed) {
    policy.approve();
  }
};

module.exports.docs = 'http://slss.io/sg-no-wild-iam-role';
//# sourceMappingURL=no-wild-iam-role-statements.js.map