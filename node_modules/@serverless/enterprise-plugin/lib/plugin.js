'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const chalk = require('chalk');

const _ = require('lodash');

const updateNotifier = require('update-notifier');

const _require = require('@serverless/platform-sdk'),
      configureFetchDefaults = _require.configureFetchDefaults,
      getLoggedInUser = _require.getLoggedInUser,
      openBrowser = _require.openBrowser;

const sfePkgJson = require('../package');

const errorHandler = require('./errorHandler');

const logsCollection = require('./logsCollection');

const login = require('./login');

const logout = require('./logout');

const wrap = require('./wrap');

const injectLogsIamRole = require('./injectLogsIamRole');

const injectOutputOutputs = require('./injectOutputOutputs');

const wrapClean = require('./wrapClean');

const runPolicies = require('./safeguards');

const getCredentials = require('./credentials');

const getAppUids = require('./appUids');

const removeDestination = require('./removeDestination');

const _require2 = require('./deployment'),
      saveDeployment = _require2.saveDeployment,
      createAndSetDeploymentUid = _require2.createAndSetDeploymentUid;

const variables = require('./variables');

const _require3 = require('./generateEvent'),
      generate = _require3.generate,
      eventDict = _require3.eventDict;

const _require4 = require('./deployProfile'),
      configureDeployProfile = _require4.configureDeployProfile;

const _require5 = require('./test'),
      test = _require5.test;

const _require6 = require('./dashboard'),
      getDashboardUrl = _require6.getDashboardUrl;

const setApiGatewayAccessLogFormat = require('./setApiGatewayAccessLogFormat');

const interactiveCli = require('./interactiveCli');
/*
 * Serverless Enterprise Plugin
 */


class ServerlessEnterprisePlugin {
  constructor(sls) {
    this.sls = sls; // Defaults

    this.state = {}; // Useful for storing data across hooks

    this.state.secretsUsed = new Set(); // forward compatibility with org

    sls.service.tenant = sls.service.org || sls.service.tenant;
    configureFetchDefaults(); // Configure commands available to logged out users

    this.commands = {
      'login': {
        usage: 'Login or sign up for Serverless',
        lifecycleEvents: ['login'],
        enterprise: true
      },
      'logout': {
        usage: 'Logout from Serverless',
        lifecycleEvents: ['logout'],
        enterprise: true
      },
      'generate-event': {
        usage: 'Generate event',
        lifecycleEvents: ['generate-event'],
        options: {
          type: {
            usage: `Specify event type. ${_.keys(eventDict).join(', ')} are supported.`,
            shortcut: 't',
            required: true
          },
          body: {
            usage: 'Specify the body for the message, request, or stream event.',
            shortcut: 'b'
          }
        },
        enterprise: true
      },
      'test': {
        usage: 'Run HTTP tests',
        lifecycleEvents: ['test'],
        options: {
          function: {
            usage: 'Specify the function to test',
            shortcut: 'f'
          },
          test: {
            usage: 'Specify a specific test to run',
            shortcut: 't'
          }
        },
        enterprise: true
      },
      'dashboard': {
        usage: 'Open the Serverless dashboard',
        lifecycleEvents: ['dashboard'],
        enterprise: true
      }
    };
    this.hooks = {
      'login:login': this.route('login:login').bind(this),
      'logout:logout': this.route('logout:logout').bind(this),
      'generate-event:generate-event': this.route('generate-event:generate-event').bind(this),
      'test:test': this.route('test:test').bind(this),
      'dashboard:dashboard': this.route('dashboard:dashboard').bind(this),
      // behavior is conditional on this.sls.enterpriseEnabled
      'after:aws:deploy:finalize:cleanup': this.route('after:aws:deploy:finalize:cleanup').bind(this)
    };
    this.variableResolvers = {
      param: {
        resolver: variables.getValueFromDashboardParams(this),
        serviceName: 'Serverless Parameters',
        isDisabledAtPrepopulation: true
      },
      secrets: {
        resolver: variables.getValueFromDashboardParams(this),
        serviceName: 'Serverless Secrets',
        isDisabledAtPrepopulation: true
      },
      output: {
        resolver: variables.getValueFromDashboardOutputs(this),
        serviceName: 'Serverless Outputs',
        isDisabledAtPrepopulation: true
      },
      state: {
        resolver: variables.getValueFromDashboardOutputs(this),
        serviceName: 'Serverless Outputs',
        isDisabledAtPrepopulation: true
      }
    }; // set allowed plugin options

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = sls.pluginManager.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const plugin = _step.value;

        if (plugin.constructor.name === 'InteractiveCli' && plugin.commands) {
          if (!plugin.commands.interactiveCli.options) {
            plugin.commands.interactiveCli.options = {};
          }

          plugin.commands.interactiveCli.options.app = {
            usage: 'Dashboard app'
          };
          plugin.commands.interactiveCli.options.org = {
            usage: 'Dashboard org'
          };
        } else if (plugin.commands) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = _.values(plugin.commands)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              const command = _step3.value;

              if (command.configDependent) {
                command.options.app = {
                  usage: 'Dashboard app'
                };
                command.options.org = {
                  usage: 'Dashboard org'
                };
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      } // Also adding in commands object of plugin man bc generating help doesn't reread the plugin
      // itself

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _.values(sls.pluginManager.commands)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        const command = _step2.value;

        if (command.configDependent) {
          command.options.app = {
            usage: 'Dashboard app'
          };
          command.options.org = {
            usage: 'Dashboard org'
          };
        }
      } // Add interactive CLI hooks

    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    Object.assign(this.hooks, interactiveCli(this)); // Check if dashboard is configured

    const missing = [];

    if (!sls.service.tenant) {
      missing.push('tenant');
    }

    if (!sls.service.app) {
      missing.push('app');
    }

    if (!sls.service.service) {
      missing.push('service');
    }

    if (missing.length > 0) {
      // user isn't configured to use SFE
      Object.assign(this.hooks, {
        'after:aws:deploy:finalize:cleanup': () => sls.cli.log('Run the "serverless" command to setup monitoring, troubleshooting and testing.')
      });
      this.sfeEnabledHooks = {};
    } else {
      if (sls.service.app.match(new RegExp(sls.service.provider.variableSyntax)) || sls.service.tenant.match(new RegExp(sls.service.provider.variableSyntax))) {
        throw new this.sls.classes.Error('"app" and "org" in your serverless config can not use the variable system');
      }

      this.sfeEnabledHooks = {
        'before:package:createDeploymentArtifacts': this.route('before:package:createDeploymentArtifacts').bind(this),
        'after:package:createDeploymentArtifacts': this.route('after:package:createDeploymentArtifacts').bind(this),
        'before:deploy:function:packageFunction': this.route('before:deploy:function:packageFunction').bind(this),
        'after:deploy:function:packageFunction': this.route('after:deploy:function:packageFunction').bind(this),
        'before:invoke:local:invoke': this.route('before:invoke:local:invoke').bind(this),
        'before:aws:package:finalize:saveServiceState': this.route('before:aws:package:finalize:saveServiceState').bind(this),
        'before:deploy:deploy': this.route('before:deploy:deploy').bind(this),
        'before:aws:deploy:deploy:createStack': this.route('before:aws:deploy:deploy:createStack').bind(this),
        'after:deploy:finalize': this.route('after:deploy:finalize').bind(this),
        'after:deploy:deploy': this.route('after:deploy:deploy').bind(this),
        'before:info:info': this.route('before:info:info').bind(this),
        'after:info:info': this.route('after:info:info').bind(this),
        'before:logs:logs': this.route('before:logs:logs').bind(this),
        'before:metrics:metrics': this.route('before:metrics:metrics').bind(this),
        'before:remove:remove': this.route('before:remove:remove').bind(this),
        'after:remove:remove': this.route('after:remove:remove').bind(this),
        'after:invoke:local:invoke': this.route('after:invoke:local:invoke').bind(this),
        'before:offline:start:init': this.route('before:offline:start:init').bind(this),
        'before:step-functions-offline:start': this.route('before:step-functions-offline:start').bind(this)
      }; // Set Plugin hooks for authenticated Enteprise Plugin features

      Object.assign(this.hooks, this.sfeEnabledHooks);
    }
  }
  /*
   * Route
   */


  route(hook) {
    var _this = this;

    return (
      /*#__PURE__*/
      _asyncToGenerator(function* () {
        // throw an error if SFE is disabled and running an SFE only hook
        if (!_this.sls.enterpriseEnabled && _.keys(_this.sfeEnabledHooks).includes(hook)) {
          const errorMessage = process.env.CI ? 'You are not currently logged in. Follow instructions in http://slss.io/run-in-cicd to setup env vars for authentication.' : 'You are not currently logged in. To log in, use: $ serverless login';
          console.log(''); // eslint-disable-line no-console

          _this.sls.cli.log(errorMessage);

          throw new _this.sls.classes.Error(errorMessage);
        }

        switch (hook) {
          case 'before:package:createDeploymentArtifacts':
            Object.assign(_this.sls.service, (yield getAppUids(_this.sls.service.tenant, _this.sls.service.app)));
            createAndSetDeploymentUid(_this);
            yield wrap(_this);
            yield injectLogsIamRole(_this);
            yield injectOutputOutputs(_this);
            yield setApiGatewayAccessLogFormat(_this);
            break;

          case 'after:package:createDeploymentArtifacts':
            yield wrapClean(_this);
            break;

          case 'before:deploy:function:packageFunction':
            createAndSetDeploymentUid(_this);
            yield wrap(_this);
            break;

          case 'after:deploy:function:packageFunction':
            yield wrapClean(_this);
            break;

          case 'before:aws:package:finalize:saveServiceState':
            yield getCredentials(_this);
            yield logsCollection(_this);
            break;

          case 'before:deploy:deploy':
            _this.enterprise = {
              errorHandler: errorHandler(_this) // V.1 calls this when it crashes

            };
            yield runPolicies(_this);
            break;

          case 'before:aws:deploy:deploy:createStack':
            break;

          case 'after:aws:deploy:finalize:cleanup':
            if (!_this.sls.enterpriseEnabled) {
              _this.sls.cli.log('Run the "serverless" command to setup monitoring, troubleshooting and testing.');
            } else {
              yield saveDeployment(_this);
            }

            break;

          case 'before:info:info':
            yield getCredentials(_this);
            break;

          case 'after:info:info':
            // eslint-disable-next-line no-console
            console.log(chalk.yellow(`Run "serverless dashboard" to open the dashboard or visit ${getDashboardUrl(_this)}`));
            break;

          case 'dashboard:dashboard':
            openBrowser(getDashboardUrl(_this));
            break;

          case 'before:logs:logs':
            yield getCredentials(_this);
            break;

          case 'before:metrics:metrics':
            yield getCredentials(_this);
            break;

          case 'before:remove:remove':
            yield getCredentials(_this);
            break;

          case 'after:remove:remove':
            Object.assign(_this.sls.service, (yield getAppUids(_this.sls.service.tenant, _this.sls.service.app)));
            yield removeDestination(_this);
            yield saveDeployment(_this, true);
            break;

          case 'before:invoke:local:invoke':
            Object.assign(_this.sls.service, {
              appUid: '000000000000000000',
              tenantUid: '000000000000000000'
            });
            yield wrap(_this);
            break;

          case 'after:invoke:local:invoke':
            yield wrapClean(_this);
            break;

          case 'before:offline:start:init':
            // await wrap(this)
            break;

          case 'before:step-functions-offline:start':
            // await wrap(this)
            break;

          case 'login:login':
            yield login(_this);
            break;

          case 'logout:logout':
            yield logout(_this);
            break;

          case 'generate-event:generate-event':
            yield generate(_this);
            break;

          case 'test:test':
            yield test(_this);
            break;

          default:
        }
      })
    );
  }

  asyncInit() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      if (_this2.sls.processedInput.options['help-interactive'] || _this2.sls.processedInput.options.help) {
        return;
      } // Filter available projects to create


      if (_this2.sls.interactiveCli && _this2.sls.interactiveCli.initializeServiceConfiguration) {
        _this2.sls.interactiveCli.initializeServiceConfiguration.initializeProjectChoices = _this2.sls.interactiveCli.initializeServiceConfiguration.initializeProjectChoices.filter(({
          value
        }) => ['aws-nodejs', 'aws-python3', 'aws-python'].includes(value));
      } // override app & tenant from CLI flags if set and not in interactive mode


      if (!_this2.sls.interactiveCli) {
        if (_this2.sls.processedInput.options.org) {
          _this2.sls.service.tenant = _this2.sls.processedInput.options.org;
        }

        if (_this2.sls.processedInput.options.app) {
          _this2.sls.service.app = _this2.sls.processedInput.options.app;
        }
      }

      const missingConfigSettings = [];

      if (!_this2.sls.service.tenant) {
        missingConfigSettings.push('tenant');
      }

      if (!_this2.sls.service.app) {
        missingConfigSettings.push('app');
      }

      if (!_this2.sls.service.service) {
        missingConfigSettings.push('service');
      }

      const user = getLoggedInUser();
      const currentCommand = _this2.sls.processedInput.commands[0];

      if (missingConfigSettings.length === 0 && (user || process.env.SERVERLESS_ACCESS_KEY) && !['login', 'logout', 'generate-event'].includes(currentCommand)) {
        _this2.sls.enterpriseEnabled = true;
      } // this.provider, intentionally not set in constructor, as then it affects plugin validation
      // in serverless, which will discard plugin when command not run in service context:
      // https://github.com/serverless/serverless/blob/f0ccf6441ace7b5cc524e774f025a39c3c0667f2/lib/classes/PluginManager.js#L78


      _this2.provider = _this2.sls.getProvider('aws');

      if (!_this2.sls.interactiveCli && _this2.sls.enterpriseEnabled && !_this2.sls.isStandaloneExecutable) {
        const updates = updateNotifier({
          pkg: sfePkgJson,
          interval: 1
        });

        if (updates.update) {
          _this2.sls.cli.log('An updated version of the Serverless Dashboard is available. ' + 'Please upgrade by running `npm i -g serverless`');
        }

        yield configureDeployProfile(_this2);
      }
    })();
  }

}

module.exports = ServerlessEnterprisePlugin;
//# sourceMappingURL=plugin.js.map